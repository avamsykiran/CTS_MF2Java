Day 1: Java Introduction
----------------------------------------------------------------------------------------

    is a high level strictly but partially object oriented progrmming.

    + Strictly object oriented, as there is no way possible to implement any java application 
      without using OOP.,
    + Partially object oriented, as java supports native variables and native types which are
      not objects and classes

    Histroy And Evolution
    ----------------------------------------
    JDK Alpha and Beta (1995)
    JDK 1.0 (23rd Jan 1996)
    JDK 1.1 (19th Feb 1997)
    J2SE 1.2 (8th Dec 1998)                             Stable  
    J2SE 1.3 (8th May 2000)
    J2SE 1.4 (6th Feb 2002)                             Stable and Prominent
    J2SE 5.0 (30th Sep 2004)                            Stable, Prominent and Revolutionary
    Java SE 6 (11th Dec 2006)
    Java SE 7 (28th July 2011)
    Java SE 8 (18th Mar 2014)   (LTS)                   Stable and Most used on current day 
    Java SE 9 (21st Sep 2017)
    Java SE 10 (20th Mar 2018)
    Java SE 11 (Sep 2018)       (LTS)                   Stable and being adopted 
    Java SE 12 (Mar 2019)
    Java SE 13 (Sep 2019)
    Java SE 14 (Mar 2020)
    Java SE 15 (Sep 2020)
    
    Java Distributions
        JRE                 Java Runtime Environment         
                                {Java Libraries,GC,JVM,Interpreter,ClassLoader,ByteCodeVerifeir,...}
        
        JDK / JSDK          Java (Standard) Development Kit    
                                {JRE, Development Tools, IDE Support}
    
    Java Editions

        Java Standard Edition 
        ==================================
                Core Language                
                Java Core Libraries
                -------------------------
                    java.lang               Exceptions, Multi-Threading
                    java.time               Date and Time API
                    java.util               Generics and Collections
                    java.util.stream        Streams API and Lambda Expressions
                    java.util.regex         Regular Expressions
                    java.io                 IO Streams
                    java.nio                New IO Streams
                    java.sql                JDBC

        Java Enterprise Edition
        ==================================
            App                 Specificaions            Implementations         Frameworks
            ----                -----------------------  ----------------        -------------
            Dynamic Web Apps    Servlets and JSP         WebServers like Tomcat  Struts
                                                                                  Spring

            ORM                 JPA, JTA                 Hibernate,TopLink,EclipseLink...
                    
            WebServices         JAX-WS, JAX-RS           Axis2,Apache CXF
                                          
            Microservices ...and more

        Java Micro Edition
        ==================================

                supports smart device / smart card based application development.


    Characteristics
    ----------------------------------------

    1: Each statement shall be terminated by a ;

        System.out.println("");

        Stream<String> = Stream.of(
                            "a","b","c","d","e","f","g"
                         );

    2: Strictly Case Sensitive

    3: Each block of statements shall be enclosed wihtin  { .... }

            static {
                System.out.println("");

                Stream<String> = Stream.of(
                                    "a","b","c","d","e","f","g"
                                );        
            }

    4: Object Oriented

    Features
    ------------------------------------------
    Simple
    Robust
    Multi-Threaded
    Distributed
    Self-Documented
    Platform Independent
    Archetecture Neutral

Day2
----------------------------------------------------------------------------------------
    
    Tokens and Coding Standards And Conventions
    ----------------------------------------------------------
        
        Keywords                    lower cased

        Operators

                        Binary Operators

                                Arithmetic
                                        +       Addition            sum
                                        -       Substraction        diff
                                        *       Multiplication      prod
                                        /       Division            Quitiont

                                            7/2     3
                                            7/2.0   3.5
                                            7.0/2.0 3.5
                                            7.0/2.0 3.5

                                        %       Division-Modulo     Reminder

                                Assignemnt

                                    =
                                                a =5;
                                                a = c+b;
                                                a = Math.min(45,657);

                                    +=,-=,/=,*=,%=

                                    a+=5;           a = a+5;

                                Relational

                                        ==, < , >, <=, >=, != 

                                Logical

                                        and     &&
                                        or      ||
                                        not     !

                                        boolean flag = a>b && b>c;
                                        boolean flag = a>b || b>c;
                                        boolean flag1 = !flag2;

                        Unary Operators
                                    -       unary minus

                                    a = v1-v2; //bianry -
                                    a = -b; //unarity - 

                                    ++      increment
                                    --      decrement

                                    int v1=78;
                                    int v2 = ++v1;                                   

                        Ternary Pair Operator     

                            rel_or_logical_expression ? expression_on_true : expression_on_false

                            int b=-109,c=0;
                            int a = b>=c?b:c;

                            value of a is 0.

                            if(b>=c){
                                a=b;
                            }else{
                                a=c;
                            }

                        Bitwise Operators

                                &       
                                |       
                                ^
                                <<
                                >>

                        Misc

                                instance of
                                ()                  function calls, type casting
                                []                  arrays 
                                {}                  block of code
                                                    initilizations
                                ;                   statement termination
                                <>                  type inferences
                                ::                  scope resolution
                                .                   memebership operator

        Comments

                    End of line comment
                    //

                    Block Comments
                    /*

                    */

                    /*
                     This class represents the detials of an Employee
                     .......................
                    */
                    class Employee{

                        private int empNumber;      //represents the employee identitiy
                        private String empName;     //represents employee full name
                        private double basic;       //represents employee basic pay
                        
                    }

        Identifiers             (Nouns)

                is any name given to a resource like variable,method,class,interfae ..etc

                1. Identifiers can be alpha numeric but can not start with a number
                        int a1,a2; //valid
                        int 1a;//invlaid

                2. Identifiers cna not compose of any symbole expect _ .

                        int MIN_COUNT;

                3. Identifiers can not fully match with a keyword

                        int intValue; //valid
                        int if; //invalid

                Naming Conventions
                ===================================


                1. variable, Objects and Method Identifiers

                    start with lowercase and follow initial capitals 
                    from the second word onwards


                    length
                    roomLength

                    emp
                    empToBeDelted

                    compare()
                    compareTo()
                    equals()
                    equalsIgnoreCase()

                2. User Defiend Data Type (class/interface/enum) Identifiers

                    Always follow initial capitals.

                    Employee
                    Exception
                    ArrayIndexOutOfBoundsException

                3. Identifiers given to Constants

                    All capitals and word are linked with a _ .

                    MIN_LIMIT
                    MAX_LIMIT
                    PI

Day 3:
----------------------------------------------------------------------------------------------

        Literals
        -----------------------------------------------

            int c = 2*PI*radius;

            keyword             int
            identifiers         radius,PI,c
            operators           = * ;
            comments
            Literals            2


            Numeric
                        Integer

                            Decimal Numdric System      0 to 9

                                    int x = 72;
                                    System.out.println(x);      72

                            HexaDecimal Numberic System 0 to 9 ,A to F

                                    int x = 0xFF9;
                                    System.out.println(x);      4089

                            Octal Numberic System       0 to 7

                                    int x = 072;
                                    System.out.println(x);      58

                            Binary Numberic System       0 and 1

                                    int x = 0b1101;
                                    System.out.println(x);      13                                    

                        Floating Pointing
                                Decimal Numdric System      0 to 9

                                    double d = 89.0;
                                    float f = 90.0f;

            Non-Numeric

                        Characters

                            char alpha1 = 'a';

                        String
                            String name=   "MF2Java Batch";

                            System.out.println("Hello Batch");

                        Boolean

                            true
                            false

                        Reference

                            null


        Java Type System
        --------------------------------------

                Primitive Type

                    char        2B

                    byte        1B
                    short       2B
                    int         4B
                    long        8B

                    double      8B
                    float       4B

                    void        ----
                    boolean     1 bit       true and false

                Reference Type / User Defined Data Types

                    class
                    enum
                    interface


        Developing An application
        -----------------------------------

            Compose the source code                         TextEditor (notpead...)
            Compile the source code                         javac Program.java    
            Test the Source code or the compiled files      -----------
            Package them                                    jar
            
            Build the application (Compiling, linking, 
            minimizing and package)

            Execute Application                             java 
            
            Deploy

            Generate Docuementation                         javadoc

            Read Documentation                              javap

        

Day 4:
----------------------------------------------------------------------------

Decison Making Control Statements

    Simple if
                    if(cond)
                        statement;

                    if(cond){
                        statement;
                    }

    if..else
                    if(cond){
                        true block of statements;
                    }else {
                        false block of statements;
                    }

    if laddder
                    if(cond1){
                        block1;
                    }else if(cond2){
                        block2;
                    }........................
                    .....else{
                        block if non of the statments are true;
                    }

    nested if

    switch

Iterative Control Statmeents

    do..while
    while
    for
    Enhanced for

Day 5:
----------------------------------------------------------------------------

    Arrays
    -----------------------------------------------------

            datatype[] arrName; //declaration
            datatype arrName[]; //declaration
            
            arrName = new datatype[size]; //allocation

            datatype[] arrName = new datatype[size]; //declaration and allocation
            datatype arrName[] = new datatype[size]; //declaration and allocation

            datatype[] arrName = new datatyoe[]{e1,e2,e3,e4........};


            for(loopingVar : array){
                ...loopingVar...
            }    


            value based allocations
            reference based allocations


            int x=90; //value based allocations

            int arr[];

            arr = new int[3]; //reference based allocation

            int arr2 = arr;

                                Stack                       Heap
                                                                r1    r2   r3
                                                                [   ][  ][  ]
                                    x [ 90 ]

                                    arr [  r1  ]
                                    arr2[  r1  ]


            Develop a java applciation
                1. to declare an array of 15 elements;
                2. then initilize that array with elements from 1 to 15.
                3. then compute and display
                        a) the smallest
                        b) the largest
                        c) sum
                        d) avg.
        ===================================================================================

        Object Oriented Programming

                    is  a programming paradigm.

            Class & Object
            Encapsulation
            Polymorphisim
            Inheretence
            Abastraction                    


        Class 
                is a user defiend datatype; to represent the 
                real time entities in terms of properties and behaviours.
                Properties are represetned by variables called fields.
                behaviours are represented by functions called methods.


                class Employee{
                    private int empId;
                    private String empName;

                    public Employee(int empId,String empName){
                        this.empid=empid;
                        this.empNAme=empName;
                    }
                }

        Object    memory allocated (variables) of type class.  

                int n = 105;

                Employee emp1 = new Employee(101,"Vamsy");
                Employee emp2 = new Employee(101,"Vamsy");

                Employee emp3;

                Employee emp3 = emp2;

                boolean flag1 = (emp1==emp2); //false
                boolean flag2 = (emp3==emp2); //true

Day 6:
----------------------------------------------------------------------------

               
        Encapsulation  --- data hiding


                Access Specifiers
                -----------------------
                    can not use on a local variable 
                    or a function arguament

                    public              public datatype varaible;

                            on a class      the class is accessable outside its package
                            on a field      are accessable any where outide the class.
                            on a method     are accessable any where outide the class.
                                            

                    private             private datatype varaible;
                    
                            on a field      are accessable only from within the class.
                            on a method     are accessable only from within the class.
                            
                    protected           protected datatype varaible;

                            on a field      are accessable from within the class and also sub-classes.
                            on a method     are accessable from within the class and also sub-classes.

                    default             datatype varaible;

                            default class

                                    classes that are not public are default class.
                                    and these can not be accessed from outside its package.

                            default field
                            default method

                                    are accessable from all classes 
                                    that belong to the same package of the
                                    owning class.


                public class Employee {
                    
                    private int empId;
                    private String fullName;
                    private double basicPay;

                    public int getEmpId(){
                        return empId;
                    }

                    public void setEmpId(int empId){
                        this.empId=empId;
                    }

                }

Day 7:
----------------------------------------------------------------------------

    constructor

            is method that gets invoked immediatly and automatically
            after the allocation of an object.

            1. a constructor shall be named after its class.
            2. a constructor shall not return anything even not void.

    default constructors => constructors that do not have any args
    parametrized constructors => constructors that have args
    copy constructor => constructor that accepts the object of the same class

    this keyword always refers to an object becasue of which the current method
    is invoked.

Polymorphisim
----------------------------------------------------------------------------
                
    multiple behaviours of the same action.

    1. Multiply the below

        (a)     23      45
        (b)     3x+4y   3y+5x
        (c)     2+i7    4-i8
        (d)     [1 2]   [1]    

    same action can have multiple behaviours when the parameters change.

    same method can have multiple Implementations when the arguments change.

    type Polymorphisim
    -----------------------------

        Constructor Overlaoding

            a class having multiple constructors with different arguments.

        Method Overlaoding

            a method of the same class
            or belonging to super and sub classes
            has multiple Implementations when the args are different.

            class Human{

                public Energy eat(Apple apple){
                    wash(apple);
                    ApplePiece[] pieces=cut(apple);
                    Energy eng = new Energy();
                    for(ApplePiece p :pieces){
                        eng.accumilate(chewAndSwallow(p));
                    }
                    return eng;
                }

                public Energy eat(Cake cake){                    
                    CakePiece[] pieces=cut(cake);
                    Energy eng = new Energy();
                    for(CakePiece p :pieces){
                        eng.accumilate(chewAndSwallow(p));
                    }
                    return eng;
                }

                public Energy eat(IceCream ice){                                        
                    Energy eng = new Energy();
                    while(!ice.complete()){
                        eng.accumilate(lick(ice));
                    }
                    return eng;
                }

            }

            Human h = new Human();
            h.eat(new Apple());
            h.eat(new Cake());
            h.eat(new IceCream());

        Method Overriding

            if two methods one belonging to the super and the other
            belonging to the sub class, have the same name, return type and 
            arguemtns but differ in the implementation, then those ae called overriden

Day 8:
----------------------------------------------------------------------------

    Inheretence

            class Pen{
                private Barrel barrel;
                private Nib nib;
                private Ink ink;

                //a
                public Text write(Paper paper){
                    ..lightly on paper...
                }
            }

            class Marker extends Pen{ //marker is like a pen

                //b
                public Text write(Paper paper){
                    ..boldly on paper...
                }

                //c
                public Text write(WhiteBoard board){
                    ..boldly on board...
                }

                //d
                public Text write(Glass glass){
                    ..boldly on glass...
                }
            }

            //Pen is called super class
            //Marker is called sub class.


            a and b are overriden

            b,c and d are overloaded


        Rules of Inheretence

            1. Simple Inheretence

                super <------------- sub

                Rectangle {l,b} <------------ Cubiod {l,b,h}

            2. Multi-Level Inheretence

                super <------ sub1  <-------- sub2 <---- sub3 ........

                Employee {empid,name,basic} <-- Manager {...,allowence} <-- Director {...,share}

            3. Hirarchial Inheretence

                            |<--- sub1
                super <-----|<--- sub2
                            |<--- sub3

                            |<--- EducationalLoan
                Loan  <-----|<--- HosuingLoan
                            |<--- PersonalLoan

            4. Multiple Inheretence     (is not support by java classes)

                super1<---- |
                            | <---- Sub
                super2<---- |


                Camera <----- |
                              |
                Torch  <----- | <-- SmartPhone
                              |  
                Mobile <----- |  

            5. Hybrid Inheretence

                            Employee
                                |
                            --------------------
                            |                   |
                        ContractEmployee       Manager
                                                |
                                               Director 

            use keyword "extends" to derive a class from another.


            Constructor Phenomena
            --------------------------------

            Employee emp = new Employee(); //Employee constructor is invoked.


            ContractEmployee cemp = new ContractEmployee(); 
            //Employee Constructor and ContractEmployee Constructor are called, in that order.

            Director d = new Director();
            //Employee Constructor, Manager Constructor and then Director Constructor


            this and super keyword
            ------------------------------

            this
                    represents the current object that invoked the method

                    + use it to refer to fields of current object:

                            this.empId = empId;
                            this.empId is  the field of the curret employee object,
                            empId is a local variable or function arg.

                    + use to call one constructor from another.


            super

                    represents the super object stub in the sub class.

                    + use to refer to the protected and public fields methods of
                    super class inside the sub class.

                    + use to call specific super class cosntructor from
                    sub class constructor.


            Assignemnt
            ------------------------

                    BankAccount
                     |
                -----------------------------------------------
                |                   |                       |
                SavingsAccount      CurrentAccount         ReocurringDepositAccount


    NOTE:

        java.lang.Object

                each and every java class
                is under the hirarchy of Object class.

                class C1{ //java compiler will make C1 extend Object
                    ...............
                }

                class C2 extends C1{
                    ...............
                }
        
                int x=90;
                System.out.println(x);

                C1 cobj = new C1();
                System.out.println(cobj);

        java.lang.Object public methods
        ------------------------------------
                
            int hashcode(); //is a unique identity given to each object.
            
            boolean equals(Object); 

            String toString(); //prints the classnae and hashcode.

            
    Type Casting (Primitive)
    --------------------------------

        converting one type into another....!


        implicit type casting

            short y=6;  int x=y;  //implicit type casting

            byto to short, short to int and int to double

        explicit type casting

            double y=3.14;
            int x=(int)y;
            short s=(short)x; 

            int code=(int)'A';
            char ch = (char)81;

    Type Casting (User defiend like classes ...etc)            
    ---------------------------------------------------

                            Employee
                                |
                            --------------------
                            |                   |
                        ContractEmployee       Manager
                                                |
                                               Director 

    Employee emp = new Employee();              //possible

    Employee emp2 = new ContractEmployee();     //possible
    Employee emp3 = new Manager();              //possible
    Employee emp4 = new Director();             //possible

    Manager mgr = new Director();               //possible

    ContractEmployee cemp = new Employee();     //not possible
    Director = new Manager();                   //not possible

    ContractEmployee cemp2 = nw Manager();      //not possible


    ContractEmployee ce4 = (ContractEmployee)emp2;  //possible @ runtime
    ContractEmployee ce5 = (ContractEmployee)emp3;  //not possible @ runtime
                                                ClassCastException

    Manager m1 = (Manager)emp4; //possible  

    Abstraction
    -------------------------------
            is the process of provding
            only the requried info and hiding the background implementations.

        Floppy   --Driver--               
        CD       --Driver--
        HDD      --Driver-- ReadWrite {Kernel}<-ReadAndWrite-{Shell}<-CopyAndPaste--End User
        PenDrive --Driver--
        Camera   --Driver--
        SSD      --Driver--


        Abstract Classes

            is a class for which no object can be allocated.
            the keyword 'abstract' is used to mark a class as abstract.

            School
                    Student
                    Parent
                    Teacher
                    NonTeachingStaff

                            abstract class Person
                                identity
                                firstName
                                lastName
                                dateOfBirth
                                contactNumber
                                |
                    -------------------------------------------
                    |           |               |           |
                    Student     Parent         Teacher      NonTeachingStaff
       
        Abstract Functions

              are function that has a known signature but no implementation.

              abstract functions can be contained by abstract classes only.

              the sub classes of an abstract class must override
              all the abstract fucntions in the abstract class, failing
              which the sub class also must be marked abstract.

                abstract class Shape {
                    private int[] sides;
                    private int[] angles;

                    public int periemter(){
                        int p=0;
                        for(int s : sides){
                            p+=s;
                        }
                        return p;
                    }

                    public abstract double getArea();
                }
                
                class Rectangle extends Shape {
                    public double getArea(){
                        return sides[0]*sides[1];
                    }
                }

        
        Interface

                is a user defiend that represents a role.
                An interface can not posses fields but can have 
                    abstract functions
                    default functions  (java 8)
                    static functions   (java 8)
                    constants.

                All members in a interface are expected to be public.


        interface           Abstract Class
        ------------------------------------------
        no fields               have fields
        only public members     any type of members
        
        represent Role          represent Entity
        and one entity can 
        any number of roles

        one class can           a class can extend in only one super class.
        implement any number of
        interfaces meaning supprot 
        multiple Inheretence
      
            Animal                                 Bird
              |                                      |                
    ---------------------                          ------------------
    |                   |                           |               |
    FemaleAnimal        MaleAnimal                  MaleBird        FemaleBird


                Mother
                    feeding()
                    giveBirth()

                Father
                    porotection()

                Sister

                Brother

Animal,FemaleAnimal,MaleAnimal,Bird,FemaleBird,MaleBird are entities 
having both fields and behaviours hence are classes.

Mother,Father,Sister,Brother are roles as they have only unimplementable (abstract)
behaviours and no fields and are interfaces.

a class can extend only from one super class
an interface can extend only from on super interface
a class can implement from more than one interfaces. (multiple inheretence).

deriving interface from a class has no sense hence not possible.


Painting Store  ----------- EstimationApp

                                estimate the cost of painting an Hoarding
                                        area * paintingRatePerUnit

                                estimate the cost of bordering a Hoarding
                                        perimeter * borderingRatePerUnit

                                the Hoarding are not always rectangle in shape,
                                they cen be circular or traingular ..etc.,

        Model                           Service                             UI                                
    representing data            computtational logic                    IO operations
    ----------------------------------------------------------------------------------------

    interface Hoarding
        getArea()
        getPerimeter()
     |
     |-CircularHoarding
     |-RectangleHoarding              class EstiamtionService{
                                        public double estimateCost(Hoarding h){
                                            h.getArea()*67.8;
                                        }
                                       }
    

    "final" keyword
    ---------------------------------------------------------

        final local variables
        final field

                its value is not changable (constants).

        final method

                such methods can not be overriden.

        final class

                such classes can not be inhereted (derived).
                no sub-classes can be created to final classes.


        'final' and 'abstract' are never used together.
       
       "static" keyword
       ------------------------------------------------------------
            static field

                class Circle{
                    
                    private static String orgName; //static fields or class-variables
                    private static final double PI = 3.14; //static fields or class-variables
                    private double radius; //non-static-field or instance-variables

                    .......
                }

                Circle c1 = new Circle();
                Circle c2 = new Circle();
                Circle c3 = new Circle();

                each and every object (instacne) of a class is
                allocated witha seperate copy of non-static fields (instacne-variables)

                only one copy of the static-fields (class-variable) is created 
                and all objects (instacnes) of the class will use that 
                same copy.

            static method

                a static method can access only other
                static members of a class. 
                (non-static members can not be accessed directly.)
                
                static emthods are refered to as class-method
                non-static emthods are refered to as instacne-method

                if a static method / field is also public
                then those methods and fields can be accesed 
                on the class (no need of an object).

                class Circle{
                    
                    public static final double PI = 3.14; //static fields or class-variables
                    private double radius; //non-static-field or instance-variables

                    .......

                    public double getArea(){
                        return PI*radius*radius;
                    }

                    public static Circle add(Circle a,Circle b){
                        //int x = radius + radius; //is meaning less
                        int x = a.radius+b.radius;
                    }
                }

                double x = Circle.PI;

                Circle c1 = new Circle();
                Circle c2 = new Circle();
                Circle c3 = Circle.add(c1,c2); //add is nto referenced by an object

                c1.getAraa(); //c1.radius is used by getArea
                c2.getArea(); //c2.radius is used by getArea              

            static class

                    Not all classes can be static.

                    Java allows us to create a class inside another class
                    only such inner class can be marked as static, 
                    adn static inner classes are called nested classes.

                    class Demo{
                        class InnerClass{

                        }

                        static class NestedClass{

                        }
                    }


            Static Block
                
                class Demo{
                    static {
                            //called a static block
                            //a class can have one and only one static block.
                            //this is executed immediatly 
                            //when a class is accessed for first time.
                    }
                }

                Accessing a class means any one of the below,
                    1. declare a refernce
                    2. allocated an object
                    3. call a static method
                    4. refer a static field.
                    5. any of the above on one of its sub-classes.


    Day - 12
    ------------------------------------------------------------------------

        Java 8 enhanceents to an interface.

                default methods

                    unlike method in a interface that are forced to be abstract,
                    if a method is marked with keyword 'default', then the
                    default method can have implementation

                static methods        


    Java Standard Libraries
    ------------------------------------------

            fully qualified clas name = package.className

                            java.lang
        
        Object                              java.lang.Object

        Wrapper Classes
                                java.lang.Integer
                                java.lang.Short
                                java.lang.Byte
                                java.lang.Double
                                java.lang.Boolean
                                java.lang.Flaot
                                java.lang.Character

                                class Patient {
                                        private Integer childCount;
                                }

                                null//no info is provided      
                                0//no children
                                1,2 ...//have children

                                Boxing =
                                    primitive variable into a wrapper object

                                        int x=89;
                                        Integer iobj = x; //auto-boxing

                                unBoxing =
                                    wrapper object into primitive variable
                                
                                        Integer iobj = new Integer(109);
                                        int x = iobj; // auto-unboxing


                                String s="10";
                                int x = Integer.pareInt(s);


        System
                public static fields
                -------------------------
                    err         : PrintStream           standard error      stderr
                    in          : InputStream           standard input      stedin
                    out         : PrintStream           standard output     stdout

                public static methods
                ------------------------

                    void exit(int); //abruptly end our application.
                    void gc(); //garbbage collector
                    String getEnvironmentVariable(String varName);
                    void setEnvironmentVariable(String varName,String value);


        Strings
                        java.lang.String
                        java.lang.StringBuilder
                        java.lang.StringBuffer


                        String s1 = new String();
                        String s2 = new String("Apple");
                        String s3 = "Hello World";

                        String objects are immutable (can not be modified).
                        Java has a separate memory called StringPool to store string.

                        String s3 = "Hello World";

                        Do "Hello World" is ther in the StringPool?
                            if Yes? s3 will have the ref of "Hello World" assigned
                            if No? then "Hello World" is created in StringPool, and
                                    s3 will have the ref of "Hello World" assigned

                        String s4 = "Hello World";
                        //both s3 an s4 will refer to the smae memory.

                        s3 = "Everyone! " + s3;

                        a new string "Evryone! Hello World" is created in StringPool
                        and s3 is redirected to refer it.

                        if want a mutable string (a modifiable string),
                        we will use StringBuffer or StringBuilder

                        java.lang.String
                        ---------------------------------
                        public java.lang.String();                        
                        public java.lang.String(char[]);
                        public java.lang.String(byte[]);
                        public java.lang.String(java.lang.StringBuffer);
                        public java.lang.String(java.lang.StringBuilder);

                        public int length();
                        public boolean isEmpty();
                        public char charAt(int);
                        public byte[] getBytes();
                        public boolean equals(java.lang.Object);
                        public boolean equalsIgnoreCase(java.lang.String);
                        public int compareTo(java.lang.String);
                        public int compareToIgnoreCase(java.lang.String);                        
                        public boolean startsWith(java.lang.String);
                        public boolean endsWith(java.lang.String);
                        public java.lang.String substring(int);
                        public java.lang.String substring(int, int);
                        public java.lang.String concat(java.lang.String);
                        public java.lang.String replace(char, char);
                        public boolean matches(java.lang.String);
                        public java.lang.String[] split(java.lang.String);
                        public java.lang.String toLowerCase();
                        public java.lang.String toUpperCase();
                        public java.lang.String trim();

                        public static java.lang.String format(String, java.lang.Object...);
                        public static java.lang.String valueOf(..primitive_types...);


                        java.lang.StringBuffer
                        ---------------------------------------------------
                        public java.lang.StringBuffer();
                        public java.lang.StringBuffer(java.lang.String);
  
                        public synchronized int length();
                        public synchronized char charAt(int);
                        public synchronized java.lang.StringBuffer append(java.lang.Object);
                        public synchronized java.lang.StringBuffer delete(int, int);
                        public synchronized java.lang.StringBuffer replace(int, int, java.lang.String);
                        public synchronized java.lang.String substring(int);
                        public synchronized java.lang.String substring(int, int);           
                        public synchronized java.lang.StringBuffer insert(int, java.lang.Object);
                        public synchronized java.lang.StringBuffer reverse();
  
                        java.lang.StringBuilder
                        ---------------------------------------------------
                        public java.lang.StringBuilder();
                        public java.lang.StringBuilder(java.lang.String);
  
                        public int length();
                        public char charAt(int);
                        public java.lang.StringBuilder append(java.lang.Object);
                        public java.lang.StringBuilder delete(int, int);
                        public java.lang.StringBuilder replace(int, int, java.lang.String);
                        public java.lang.String substring(int);
                        public java.lang.String substring(int, int);           
                        public java.lang.StringBuilder insert(int, java.lang.Object);
                        public java.lang.StringBuilder reverse();
  
                        Develop a java application for accepting
                        a para of text.
                        Analyze and display the below from the given para:
                            Number of sentences
                            Number of words.
                            Number of characters.
                            Number of alphabets.
                            Number of digits.
                            Number of non-alphanumeric characters.

        Exception Handling
        --------------------------------

                Exception object is an object
                that represents a situation
                where the application broke down.

                            java.lang.Throwable (i)
                                    |
                                    |
                        ---------------------------------
                        |                               |
                        java.lang.Error         java.lang.Exception
                                                        |
                                                        |
                                                java.lang.RuntimeException

                UnChecked Exceptions

                            if a method is supposed to raise
                            an unchecked exception, the compiler will
                            not force to handle unchecked exceptions

                            all exception classes that are
                            dereived from RuntimeException class are
                            identified as UnChecked.

                            we are not forced to handle UnChecked Exceptions
                            because they can be avoided through
                            defensive programming.

                            Employee emp;
                            emp = new Employee();
                            emp.setName("Lavanya");//NullPointerException is avoided.

                            public void processHike(Employee emp){
                                if(emp!=null){
                                    emp.setBasic(emp.getBasic()+10000); //NullPointerException is avoided
                                }
                            }

                Checked Exceptions
                
                            if a method is supposed to raise
                            an checked exception, the compiler will
                            forces to handle checked exceptions
                                                    
                            all exception classes that are
                            dereived from Exception class are
                            identified as Chekced.

                            download a file, IOException
                            database connection broken.   SQLException

                            try{
                               ....the code that may raise an exception     
                            }catch(Exception exp){
                                ..do the alternate or display a user understandable message.
                            }


        user Defiend Excepitons

            create a checked exception
              class MyCheckedException extends Exception {
                  
                  MyCheckedException(String errMsg){
                      super(errMsg);
                  }
              }

            create an unchecked exception
              class MyUnCheckedException extends RuntimeException {
                  
                  MyUnCheckedException(String errMsg){
                      super(errMsg);
                  }
              }

            "throw" keyword is used to raise an exception
                throw new MyCheckedException("error message");

            "throws" keyword is used to tranfer the exception
            from a method to its caller method. 

Day 15
----------------------------------------------------------------------------

		try {
			double updateBal = bService.withdraw(acc, amt);
			System.out.println(updateBal);
		} catch (InvalidWithdrawAmountException exp) {
			System.out.println(exp.getMessage());
		} catch (InsufficientBalanceException exp) {
			System.out.println(exp.getMessage());
		}

        Multi-catch
        ---------------------------------------------------------------
		try {
			double updateBal = bService.withdraw(acc, amt);
			System.out.println(updateBal);
		} catch (InvalidWithdrawAmountException | InsufficientBalanceException exp) {
			System.out.println(exp.getMessage());
		}
        

        finally block
        ------------------------------------
            a finally block of a try..catch
            contains code that has to be executed at any cost.

            mostly finally block is used to 
            close all used resources even if the 
            mtehod is to termiante. to avoid memory leaks.

        try-with-resources
        --------------------------

            try(declare closable resourceses here....){
                    ........................
            }catch(....){

            }

            the closable resource will be clsoe automatically.

            a Resource has to implement java.lang.Closable interface
            to be recognized as closable.

        Date and Time API                       
        ------------------------------------------------------------
        java.time        
                    LocalDate
                    ZonedDate
                    LocalTime
                    ZonedTime
                    LocalDateTime
                    ZonedDateTime

                                public class (static) methods
                                        .now()
                                        .of(year,month,day)
                                        .of(hour,min,sec)                                                            
                                        .of(year,month,day,hour,min,sec)  
                                        .parse(String,dateTimeFormatter)

                                public instance (non-static) methods                  
                                        .toString()
                                        .format(dataTimeFormtter)
                                        .plus....
                                        .minus...

            DateTimeFormatter                                        
                                .ofPattern(String pattern);

                                d           day
                                dd          day with leading zeros
                                ddd         day in words

                                M           month
                                MM          month with leading zeros
                                MMM         Three lettered Month name
                                MMMM        comple month name

                                yy , yyyy   Year

                                h,hh        hour in 12 hr format
                                H,HH        hour in 24 hr format

                                mm          min

                                ss          sec

            Duration            timespace between two time instacnes in terms of days,hrs,mins
            Period              timespace between two date instacnes in terms of days,yrs,months


            Assignment:
            -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

            Develop a java app:
                1. to accept the loan detials
                    a) loan amount
                    b) rate of interest
                    c) time period in month
                    d) date of laon disbursment

                2. validate (using excetions) such that
                    a) amount, rate of interest and time period can not be negtive.
                    b) date of loan disbursment can not be a future date

                4. display
                    a) total simple interest
                    b) date of total repayments
                    c) amoutn payable

        Generics and Collections                java.util

            ADT - Abstract Data Type - Generic

                swap    e1 and e2
                        t  = e1;
                        e1 = e2;
                        e2 = t;

            java.util

                    Scanner         used for scanning input from a InputStream
                    Random          used for generating random number.

Collections
----------------------------------------------------------------------------

    is the java approach to data structures.

    java.util

            ================== DECLARATION (interfaces) ==============================

            Collection                          Map
                |                                |
            ---------------                     SortedMap
            |             |  
            Set         List


            Collection          a non-key-value pair data structure

                                void add(element);
                                void remove(element);
                                boolean contains(element);
                                int size();
                                boolena isEmpty();
            
            Set                 a non-linear data structure
                                Elements can not be numbered (no index)
                                Elements can be acceessed only in sequential but not random manner
                                Elements can not be repeatative.(no duplicates allowed)
                                One null is allowed

            List                a linear data structure 
                                Elements can be numbered (has index)
                                Elements can be acceessed both sequentially and randomly.
                                Elements can be repeatative.                                
                                Nulls are allowed.

                                int indexOf(element);
                                int indexOf(element,int occurence);
                                void set(element,int);
                                void add(eleemnt,int);
                                Element getElementAt(int);
                                void removeAt(int);

            Map                 a key-value pair data structure
            SortedMap           a key-value pair data structure, sorted on the key

                                put(key,value);
                                set(key,value);
                                get(key);
                                keySet();
                                valueSet();
                                containsKey(key);

            ================== DECLARATION (classes) ==============================

            the Set interface is implemented by

                    HashSet             order of retrival is indefinite.
                    TreeSet             order of retrival is sorted by magnitude.
                    LinkedHashSet       order of retrival is entry order

            the List interface is implemented by                    

                    Vector          uses an array internally
                                    is synchronized (thread-safe)
                    ArrayList       uses an array internally
                                    is not synchronized (not thread-safe)
                    LinkedList      uses a reference chain of doubly linked list
                    
                    Stack           is a list that follows LIFO.
                    Queue           is a list that follows FIFO.


            Map Implementations

                    HashMap          order of retrival of keys is indefinite.
                    LinkedHashMap    order of retrival of keys is entry order
                    TreeMap          order of retrival of keys is sorted order 


            ================== ALGORITHM  ==============================

            java.lang.Comparable
                    int compareTo(Object);

            java.util.Comparator
                    int compare(Object,Object);

            java.util.Collections
            java.util.Arrays
        
            Navigable Collection
            Concurrent Collection

        Lambadas and Streams API                java.util.stream
        -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


            Lamdba expression is an inline implementation 
            for a functionalInterface.

            functionalInterface are interface that have only 
            one abstract method.

            public class EmpNameComparator implements Comparator<Employee>{

        	    @Override
	            public int compare(Employee o1, Employee o2) {
		            return o1.getName().compareTo(o2.getName());
	            }

            }

            Comparator<Employee> empNameComparator = (o1,o2) -> {
                    return o1.getName().compareTo(o2.getName());
            };

            Comparator<Employee> empNameComparator = 
                (o1,o2) -> o1.getName().compareTo(o2.getName());

            Supplier        no params, but returns
            Consumer        have params, but doesnt return
            Predicate       always returns boolean.
            Functional      has params and also retrun value.


            Streams API
            --------------------------------------------------
                Stream is a flow data from a data source.
                data source can be an array or a collection

                java.util.stream.Stream

                        Stream s = Stream.of(array)

                        Stream s2 = list.stream();
                        Stream s2 = set.stream();

                        void  forEach(Consumer)             Terminal Stream Operator.
                        Optional<E> reduce(BinaryOperator)  Terminal Stream Operator.
                        Collection  collect(Collector)      Terminal Stream Operator.

                                                Collectors.toList()
                                                Collectors.toSet()
                                                                ...............

                        Stream<E> filter(Predicate)        Intermidate Stream Operator.
                            
                        Stream<E> map(transformer)   Intermidate Stream Operator.
                            
                            flatMap

                    int[] nums = {1,2,3,4,5};

                    Stream.of(nums).reduce((n1,n2) -> n1+n2 ); ((((1+2)+3)+4)+5)
                    Stream.of(nums).reduce((n1,n2) -> n1>n2?n1:n2 ); 

                    Stream.of(nums).filter((n) -> n%2==0).forEach(System.out::println);

                    Stream.of(nums).map((n) -> n*n).forEach(System.out::println);
                    
                    reduce function return an java.util.Optional 



                    for loop    vs          Streams         vs    ParallelStreams
                    -----------------------------------------------------------

                    Outperforms             performs ok           Outperforms 
                    when the data size                            when the data size is huge  
                    is low

                    low maintainability     High maintainability    High maintainability

                    low readabilty          High readability        High readability

                    
        IOStreams                               java.io

            Binary Streams

                    read and write data only in the form of bytes

                    InputStream  (System.in)   OutputStream
                        FileInputStream           FileOutputStream
                        ObjectInputStream         ObjectOutputStream
                                                  PrintStream  (System.out)
                                                        print
                                                        println      

            Character Streams / Text Streams

                    read and write data only in the form of strings

                    Reader                      Writer
                        InputStreamReader
                        BufferedReader              PrintWriter
                        FileReader                  FileWriter                      

            File
            IOException

            https://docs.oracle.com/javase/7/docs/api/java/io/package-tree.html


            Write an object into a stream, serialization
            Read an object from  a stream, deserialization

            For any java object to be serialized or deserialized, the
            class must implement Serializable

            Serializable is a marker interface,
            which means it does not any functions in it.


        Multi-Layer Archetecture
        --------------------------------------------------------

        PersistenceUnit <----------> Application <-------------> EndUser
        (Files/databae)

        PersistenceUnit <--> [ DAO <--> SERVICE <---> UI ] <---> EndUser
        (Files/databae)

        UI          User interface
                            1. accept instruction or menu options from EndUser
                            2. accept the data
                            3. display the data
                            4. interact with the service to perform operatons

        Servie      Service Layer 
                            1. Host bussiness logic
                                a. validations
                                b. computations
                                c. analysis                              
                            2. interact with DAO to perform persistence

        DAO         Data Access Object / Repository
                            1. to interact with the underlying
                                    PersistenceUnit (Files/Database)

        Each layer should compose of an interface and its implementation for
        each domain. Interface is going to abstract the consuming from
        the providing. 

        Assignemnt to create  CRUD application on
        Student entity:
            studentId  int
            fullName   String
            admnDate   LocalDate
            fee         double      
            gstOnFee    double
            totalFee   double

        Maven
        -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-
                is a build tool.

                Ant,Gradle ae a few of that kind.

                App Dev Tasks
                    1. download and add thrid party libraries (jars)
                    2. test
                    3. build
                    4. package


                Build tool automates all thsoe for a developer.


                POM
                ------------------------------
                    Project Object Model

                    pom has the confguration that maven has to know
                    to autoamte teh build tasks on our app.


                    pom.xml
                    ----------------------------------------

                        identity(meta-data):
                                groupId
                                artifactId
                                version

                        properties
                                global maven variables 
                                use these to hold versions of differetn dependencies

                        dependencies
                                a list of thrid party libraries

                        build
                                is a step by step task execution
                                strategy of a project.

                                plugin is a peice of software that execute a task

                                maven-compiler-plugin           compileing java app
                                maven-surefire-plugin           exectuing test cases.
        
        Java Data Base Connectivity             java.sql

                Java 8          JDBC 4.0

                JDBC is a specification.

                    a specification is a set of declaration
                    to notify what are the requried fuctionalitites
                    for a technology.

                    it si requried that a third party org
                    should come forward and provide the implementations
                    for the specification.

            DB  <--JDBC--> APP      

            Oracle        <----> Thin Driver       <---> JDBC  <---> APP
            Ms SQL Server <----> Jet Driver        <---> JDBC  <---> APP
            MySQL         <----> ConnectorJ Driver <---> JDBC  <---> APP


            Jdbc Driver Types
            --------------------------
                Type1           Jdbc-Odbc Bridge driver
                Type2           Native JDBC Driver  (c,c++)
                Type3           Netwrok Adapter Drivers
                Type4           All Java Drivers

            Jdbc API
            -----------------------
                    java.sql

                            DriverManager       class

                            Connection          is a channel of communication
                                                is used manage the transactions

                            Statement           is used to execute DDL,DML,DRL commands
                            PreparedStateemnt   is used to execute DDL,DML,DRL commands
                            CallableStatement   is used to execute a stored proc/fun
                            ResultSet           is used to hold the data after executing a 'select'
                            ResultSetMetaData   is used to retrive meta data like
                                                    no of cols
                                                    col names
                                                    col types
                                                    col label .,..etc
                                                    of the data held by a ResultSet
                            DatabaseMetaData    is used to retrive the metadata related to 
                                                    the current database like
                                                        database product name
                                                        database version
                                                        sql keywords supported by the database ..ect    

                    JDBC Steps
                    -----------------------------------

                    Step 1: Load Database JDBC driver

                            java.lang.Class.forName("driver fully qualified class name");

                            Class.forName("com.mysql.cj.Driver");

                            this step is no more requried JDBC 4.0,
                            JDBC 4.0 will auto-detect any drivers in the classpath
                            and they exist, theya re loaded automatically.

                    Step 2: create a Connection

                            Connection con = DriverManager
                                    .getConnection(dbUrl,dbUserId,dbPassword);

                                        dbUrl
                            oracle      jdbc:oracle:thin:@localhost:5421:XE
                            mysql       jdbc:mysql://localhost:3306/dbName
                            postgree    jdbc:postgresql://localhost:4321/postgree

                    Step 3:

                         a) Retrive metadata of database

                                DatabaseMetaData dbmd = con.getMeatData();

                         b) execute DML/DRL queries

                                DRL

                                Statement st = con.createStatement();
                                ResultSet rs = st.executeQuery("select * from depts");
                                while(rs.next()){
                                    rs.get.....(colNumber)
                                }

                                PreparedStatement pst = con.prepareStatement("select * from depts");
                                ResultSet rs = pst.executeQuery();
                                while(rs.next()){
                                    rs.get.....(colNumber)
                                }

                                DML

                                Statement               executeUpdate(qry)      int
                                PreparedStateemnt       executeUpdate()         int
                                
                                    
                         c) execute a procedure or fuction

                                CallabelStatement

           
           
           Coupling

                degree of isolation (dependency) among modules
                loosely coupled projects ensure high maintainability.

           Cohesion 

                degree of similarity of operations grouped in a module.

                DAO         data access                       
                Service     a method to compute the number of leaves

                Higher the Cohesion higher the maintainability.

            Dependency Injection:

                DI is an approch to IoC pattern
                IoC - Inversion of control.

                DI enhances the couple to be more loose.

                By Constructor
                By Setter

        Multi-Threading

                Multi-Tasking

                    the ability of an OS
                    to execute more than one applications simultaniously.

                    1. each task is called a Process
                    2. Every process will have it own
                        a) id
                        b) stack
                        c) heap
                        d) registries
                    3. Use JobScheduling algorithms to share
                            time slices among multiple processes.
                    4. inter-process communication is not possible or exepcted.

                Multi-Threading     

                    the ability of an application
                    to execute one or more operations simultanuosly.

                    1. Each operation is called a Thread
                    2. Every Thread will have it own
                        a) threadName
                        b) stack
                    3. All Thread will have the same    
                        a) processId
                        b) Heap
                        c) registeries
                    4. Use thread scheduling for sharing the time slice among the threads.
                    5. inter-thread communication is expected and is possible.
                    
                Thread API
                ----------------------------

                java.lang.Runnable      void run()
                            |
                            |
                            java.lang.Thread
                                        Thread()
                                        Thread(String)
                                        Thread(Runnable)

                                        static Thread currentThread()
                                        static void sleep(long) throws InterruptedException
        
                                        void start();
                                        void setName(String);
                                        String getName();
                                        void setPriority(int);      0 to 10; default 5
                                        int getPriority();
                                        void join();

                    Thread Life Cycle
                    ========================================

                     new Thread()       initiated       
                                            | start()
                                            |
                                            
                                   Ready (Queued)... ----(Resource Availability) --|
                                                                                  |
                                      | (notified)                                 
                                    Suspend (sleep/wait..) ----------- Execution..(run())
                                                                                   |
                                                                                    (complte)
                                                                                Terminated                                                                                         
                                                                  
                                 Consumer/Producer Problem
                                 -------------------------------
                                 
                                 java.lang.Object
                                                wait()
                                                wait(long)           
                                                notify()
                                                notifyAll()

                                ThreadPool
                                -----------------------------------
                                
                                1. Creating ane thread is a costly process.
                                2. Thread context switching is another costlier process.

                                    Executor Pattern

                                        SingleThreadExecutor
                                        FixedThreadExecutor ...


        JUnit

                Testing Platform + Test Runner + Test Engine + Test Api

                for Java [unit] testing.

                Test Api            All that is needed to wrtie automated test cases


                            TestCase        is a function that executes a 
                                            specific senario and varifies for
                                            an expected output.

                                            @Test   marks a function as a test case

                            TestRun         One execution of one testcase is a test run.

                                            Same testcase executed for 5 time = 5 test runs
                                            5 testcases executed for 1 time = 5 test runs

                            Test Suite      A collection of test cases 
                                            is a test suite.

                            Assertion       is a matcher kind of a thing 
                                            on (expected on actula output)
                                            that decide wheather a test case is passed or failed.



                Test Engine         That execute the test cases

                Test Runner         That makes the test cases execute on the test engine
                                    and generate the test reprots .

                Test Platform       Is just a UI plugin / supprot for the IDE
                                    in which the test cases are being executed.

        log4j

        

